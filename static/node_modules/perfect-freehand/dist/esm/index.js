function Z(t, e, o, M = g => g) {
    return t * M(.5 - e * (.5 - o))
}

function E(t, e) {
    return [t[0] + e[0], t[1] + e[1]]
}

function x(t, e) {
    return [t[0] - e[0], t[1] - e[1]]
}

function z(t, e) {
    return [t[0] * e, t[1] * e]
}

function gt(t, e) {
    return [t[0] / e, t[1] / e]
}

function G(t) {
    return [t[1], -t[0]]
}

function mt(t, e) {
    return t[0] * e[0] + t[1] * e[1]
}

function T(t, e) {
    return t[0] === e[0] && t[1] === e[1]
}

function dt(t) {
    return Math.hypot(t[0], t[1])
}

function xt(t) {
    return t[0] * t[0] + t[1] * t[1]
}

function nt(t, e) {
    return xt(x(t, e))
}

function _(t) {
    return gt(t, dt(t))
}

function I(t, e) {
    return Math.hypot(t[1] - e[1], t[0] - e[0])
}

function at(t, e) {
    return z(E(t, e), .5)
}

function K(t, e, o) {
    let M = Math.sin(o),
        g = Math.cos(o),
        R = t[0] - e[0],
        s = t[1] - e[1],
        y = R * g - s * M,
        j = R * M + s * g;
    return [y + e[0], j + e[1]]
}

function H(t, e, o) {
    return E(t, z(x(e, t), o))
}

function h(t, e, o) {
    return E(t, z(e, o))
}
var {
    min: V,
    PI: St
} = Math, lt = .275, N = St + 1e-4;

function ft(t, e = {}) {
    var it;
    let {
        size: o = 16,
        smoothing: M = .5,
        thinning: g = .5,
        simulatePressure: R = !0,
        easing: s = r => r,
        start: y = {},
        end: j = {},
        last: w = !1
    } = e, {
        cap: L = !0,
        taper: v = 0,
        easing: U = r => r * (2 - r)
    } = y, {
        cap: d = !0,
        taper: l = 0,
        easing: q = r => --r * r * r + 1
    } = j;
    if (t.length === 0) return [];
    let rt = t[t.length - 1].runningLength,
        ot = Math.pow(o * M, 2),
        f = [],
        S = [],
        $ = t.slice(0, 10).reduce((r, P) => {
            let a = P.pressure;
            if (R) {
                let u = V(1, P.distance / o),
                    p = V(1, 1 - u);
                a = V(1, r + (p - r) * (u * lt))
            }
            return (r + a) / 2
        }, t[0].pressure),
        k = Z(o, g, t[t.length - 1].pressure, s),
        st, ut = t[0].vector,
        C = t[0].point,
        X = C,
        c = C,
        m = X,
        J = !0;
    for (let r = 0; r < t.length - 1; r++) {
        let {
            pressure: P
        } = t[r], {
            point: a,
            vector: u,
            distance: p,
            runningLength: n
        } = t[r];
        if (r > 0 && J && n < o / 2) continue;
        if (J && (J = !1), g) {
            if (R) {
                let F = V(1, p / o),
                    et = V(1, 1 - F);
                P = V(1, $ + (et - $) * (F * lt))
            }
            k = Z(o, g, P, s)
        } else k = o / 2;
        st === void 0 && (st = k);
        let i = n < v ? U(n / v) : 1,
            O = rt - n < l ? q((rt - n) / l) : 1;
        k = Math.max(.01, k * Math.min(i, O));
        let D = ((it = t[r + 1]) == null ? void 0 : it.vector) || u,
            tt = mt(u, D);
        if (tt < 0) {
            let F = z(G(ut), k);
            for (let et = 1 / 13, Y = 0; Y <= 1; Y += et) m = K(E(a, F), a, N * -Y), c = K(x(a, F), a, N * Y), S.push(m), f.push(c);
            C = c, X = m;
            continue
        }
        let pt = z(G(H(D, u, tt)), k);
        c = x(a, pt), m = E(a, pt);
        let ct = r < 2 || tt < .25;
        (ct || nt(C, c) > ot) && (f.push(c), C = c), (ct || nt(X, m) > ot) && (S.push(m), X = m), $ = P, ut = u
    }
    let b = t[0],
        B = t[t.length - 1],
        A = J || S.length < 2 || f.length < 2;
    if (A && (!(v || l) || w)) {
        let r = 0,
            P = T(b.point, B.point) ? E(b.point, [1, 1]) : B.point;
        for (let p = 0; p < t.length; p++) {
            let {
                pressure: n,
                runningLength: i
            } = t[p];
            if (i > o) {
                r = Z(o, g, n, s);
                break
            }
        }
        let a = h(b.point, G(_(x(b.point, P))), -(r || k)),
            u = [];
        for (let p = 1 / 13, n = p; n <= 1; n += p) u.push(K(a, b.point, N * 2 * n));
        return u
    }
    let Q = [],
        W = [];
    if (f.length > 1 && S.length > 1) {
        m = S[1];
        for (let n = 1; n < f.length; n++)
            if (!T(m, f[n])) {
                c = f[n];
                break
            }
        if (L || v)
            if (!v && !(l && A)) {
                if (!T(m, c)) {
                    let n = h(b.point, _(x(c, m)), -I(m, c) / 2);
                    for (let i = 1 / 13, O = i; O <= 1; O += i) {
                        let D = K(n, b.point, N * O);
                        if (I(D, c) < 1) break;
                        Q.push(D)
                    }
                    f.shift(), S.shift()
                }
            } else Q.push(b.point.slice(0, 2));
        else if (!T(m, c)) {
            let n = _(x(c, m)),
                i = I(m, c) / 2;
            Q.push(h(b.point, n, -i), h(b.point, n, -i * .95), h(b.point, n, i * .95), h(b.point, n, i)), f.shift(), S.shift()
        }
        let r = f[f.length - 1],
            P = S[S.length - 1],
            a = at(r, P),
            u = B.point,
            p = G(_(x(u, a)));
        if (d || l)
            if (!l && !(v && A)) {
                let n = h(u, p, k);
                for (let i = 1 / 29, O = 0; O <= 1; O += i) {
                    let D = K(n, u, N * 3 * O);
                    W.push(D)
                }
            } else W.push(u.slice(0, 2));
        else {
            let n = H(a, u, .95),
                i = k * .95;
            W.push(h(n, p, i), h(u, p, i), h(u, p, -i), h(n, p, -i))
        }
    }
    return f.concat(W, S.reverse(), Q)
}

function bt(t, e = {}) {
    var U;
    let {
        streamline: o = .5,
        size: M = 16,
        last: g = !1
    } = e;
    if (t.length === 0) return [];
    let R = .15 + (1 - o) * .85,
        s = Array.isArray(t[0]) ? t : t.map(({
            x: d,
            y: l,
            pressure: q = .5
        }) => [d, l, q]);
    s.length === 1 && s.push([...E(s[0], [1, 1]), s[0][2] || .5]);
    let y = [{
            point: [s[0][0], s[0][1]],
            pressure: s[0][2] || .25,
            vector: [1, 1],
            distance: 0,
            runningLength: 0
        }],
        j = !1,
        w = 0,
        L = y[0],
        v = s.length - 1;
    for (let d = 1; d < s.length; d++) {
        let l = g && d === v ? s[d] : H(L.point, s[d], R);
        if (T(L.point, l)) continue;
        let q = I(l, L.point);
        if (w += q, d < v && !j) {
            if (w < M) continue;
            j = !0
        }
        L = {
            point: l,
            pressure: s[d][2] || .5,
            vector: _(x(L.point, l)),
            distance: q,
            runningLength: w
        }, y.push(L)
    }
    return y[0].vector = ((U = y[1]) == null ? void 0 : U.vector) || [0, 0], y
}

function ht(t, e = {}) {
    return ft(bt(t, e), e)
}
var jt = ht;
export {
    jt as
    default, ht as getStroke, ft as getStrokeOutlinePoints, bt as getStrokePoints
};